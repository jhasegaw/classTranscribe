 [{"text":"so what about strings in c?","width":131},{"text":"what if I said","width":99},{"text":"\"hello\"","width":79},{"text":"how is this represented? well clearly it's made up of characters","width":214},{"text":"and I've got five characters to display","width":218},{"text":"h e l l o, but actually C strings contain an extra character at the end","width":325},{"text":"a zero value or null character to say \"hey this is the end of the string\"","width":383},{"text":"so this is going to take six bytes of storage","width":196},{"text":"let's see if we can prove that","width":106},{"text":"we'll say printf() and \"Size of hello is %d\"","width":420},{"text":"and we'll have a little expression here to say what is the sizeof() \"hello\"","width":658},{"text":"and we'll print it out and you see that size of hello is 6","width":477},{"text":"h e l l o that's five, plus an extra byte for the 0 to say that's the end","width":410},{"text":"so we can use sizeof() on constant strings","width":339},{"text":"we could also run through the string to actually find the 0 byte ourselves","width":408},{"text":"so let's do that","width":79},{"text":"let's have a pointer to a character","width":279},{"text":"I will initialize it to my string \"hello\"","width":347},{"text":"which means pointer is initially pointing to h the first character","width":448},{"text":"I'll have a little count variable here","width":161},{"text":"and let's say \"while the pointer the value is not equal to 0\"","width":676},{"text":"I want to do something","width":83},{"text":"lets increment the pointer","width":72},{"text":"lets move it onto the next character","width":115},{"text":"and let's increment our count as well","width":185},{"text":"so we can find out how many characters we have","width":261},{"text":"and then at the end we will say how many characters we found","width":461},{"text":"which are not the 0 byte","width":276},{"text":"so if our program works this should find five characters","width":324},{"text":"lets run it and i'll put in a new line at the end","width":707},{"text":"our little loop went around five times and all it did was increment count","width":302},{"text":"we could have made it of course print out each one of those letters","width":254},{"text":"we could also simplify our program a little bit","width":142},{"text":"because as you know any non-zero value is treated as true","width":342},{"text":"so let's remove that and say while star pointer","width":245},{"text":"and when we get to the null byte we will finish","width":197},{"text":"so just for fun lets change our program as well before we increment the pointer to print out the next characters","width":603},{"text":"my format string is just %c. and what character would I want? well the one pointed to by the pointer","width":493},{"text":"pointers to characters that Â each character is exactly one byte","width":353},{"text":"so when we add one to our pointer, line ten here","width":266},{"text":"we are actually just going to add one to it","width":176},{"text":"because each character is exactly one byte","width":165},{"text":"so there's our program and it managed to print out exactly \"hello\"","width":538},{"text":"do we need to write this every time that we want to find out the number of characters in a string?","width":397},{"text":"no! guess what there's a function called strlen()","width":190},{"text":"so instead of my little loop if I include string.h","width":413},{"text":"I've now got strlen()","width":92},{"text":"so let me check the two results","width":212},{"text":"instead I'll say len is strlen() and pass it a pointer to my character","width":394},{"text":"I'm tempted to use pointer but that would be a bad idea","width":209},{"text":"perhaps you can figure out why","width":159},{"text":"so \"Strlen returned\" and we'll talk about how to fix my program in a moment","width":621},{"text":"so we'll run this","width":454},{"text":"strlen() returned 0","width":104},{"text":"why? because by the time my loop finished I'd advanced that pointer on until it had reached that null byte","width":395},{"text":"so when we passed that to strlen() it immediately found the null byte","width":209},{"text":"now what we should do is evaluate our strlen() before we change our pointer","width":962},{"text":"the last thing we'll do today is make our program crash","width":201},{"text":"let's try and change our first character to be someting else","width":396},{"text":"like 'J' turn it into Jello","width":283},{"text":"so let's dereference that pointer and use it to push in a character","width":397},{"text":"I don't want to have a string, i actually want to have a character","width":322},{"text":"let's try that and see what happens","width":296},{"text":"I get a segmentation fault when I try to run that line","width":189},{"text":"here's why, different parts of my proccesses' memory are valid for reading or reading and writing","width":549},{"text":"the program code, the actual assembly, the actual instructions for the cpu, can only be read","width":418},{"text":"and my constants, such as this \"hello\" can only be read","width":274},{"text":"and the hardware is sophisticated enough to know which parts of memory are read and which parts of memory are read/write","width":487},{"text":"and which parts of memory are invalid","width":147},{"text":"so that's why I get a segmentation fault if I try to change the constant memory","width":383},{"text":"alright time for you to play with character poitners, bye","width":270}]