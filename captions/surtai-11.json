[{"text":"Hello! Let's talk about automatic variables","width":204},{"text":"so here's my main method I've got two function calls f1 f2","width":328},{"text":"and today I'm going to actually define them before my main method","width":266},{"text":"so I don't need to put in the additional declares in","width":211},{"text":"so let's have f1 here and f2...ok","width":353},{"text":"so now I've got a syntactically correct program","width":257},{"text":"but I want to talk about the variables that we might put inside these","width":182},{"text":"so if I create a variable like this to say \"hey I've got a value here, something I need to compute inside f1\" or maybe I want to make an array","width":718},{"text":"so here's my array and I can initialize it to, say, \"f1f1\" here we go","width":529},{"text":"then the lifetime of my array (this variable) is only for the lifetime of the function","width":456},{"text":"when I return from f1, then the variable goes out of scope","width":307},{"text":"which means the name \"array\" doesn't mean anything anymore inside our program","width":271},{"text":"but secondly, the memory that we were using for the array is automatically free'd up","width":298},{"text":"it can be reused for other purposes in a moment by the rest of the program","width":197},{"text":"so isn't that fantastic","width":131},{"text":"that's why it's called an automatic variable","width":160},{"text":"so automatic variables are very easy to use","width":140},{"text":"they also come with a big warning sticker and that's this","width":273},{"text":"which is to be very wary of just how long they live for","width":440},{"text":"let's do a couple of things here","width":126},{"text":"first of all, let's make it so that we can actually see the pointer in memory where array is pointing to","width":671},{"text":"so, let's print that out inside our function here","width":341},{"text":"remember that the name of the array (when converted to address) gives us the very beginning of the array","width":400},{"text":"and, we'll do that for our second function too","width":172},{"text":"okay, so, f2 f2","width":220},{"text":"just to prove that they're making different arrays","width":215},{"text":"okay, so we'll compile and run this","width":190},{"text":"and, when we run it, we see that both f1 and f2 both these functions the array is actually stored inside the same memory location","width":864},{"text":"isn't that fantastic. we didn't need any additional memory","width":155},{"text":"and that's because after we return from f1, any of those automatic variables are free'd so they are no longer needed so we can reuse that space","width":598},{"text":"internally, later we'll discover that a stack data structure is used to implement this","width":497},{"text":"and I can show a little bit of this by having a either a recursive function or we can make another function call these","width":611},{"text":"so for example, I could have a function called eg","width":421},{"text":"and, this calls f1","width":146},{"text":"so now let's have a look in the case that I'm not using f2 anymore","width":363},{"text":"so that can go away","width":180},{"text":"instead, I've got a function called eg and that can say have its own space","width":365},{"text":"so, blah and maybe say a thousand and twenty four bytes here","width":571},{"text":"and then we call f1 again","width":142},{"text":"so let's run this now","width":474},{"text":"so, in the output, you'll see that f1 is printed twice and the second time it's because it's being called from our function eg","width":784},{"text":"and in this case, it's further down in the stack. it's in lower memory","width":348},{"text":"f948 as opposed to fd50","width":154},{"text":"because it's being called from eg","width":335},{"text":"so, we'll see more about the stack in a moment","width":162},{"text":"later on. I just wanted to show you that they really are stored in different places","width":326},{"text":"finally, to reinforce this idea, let's make a little recursive function","width":348},{"text":"so, I can have something which takes an integer say I'll call it \"level\"","width":488},{"text":"and if level is greater than zero, let's call ourselves again with a slightly reduced value","width":667},{"text":"and I can of course make that simpler by just saying \"if level\"","width":272},{"text":"so if level is nonzero, then call it again","width":125},{"text":"and let's call it with say five","width":178},{"text":"okay, a semicolon would help","width":303},{"text":"each case as we go deeper and deeper into recursion, our array is getting lower and lower and lower in memory","width":587},{"text":"so we have all of these arrays created. all of these different activation records in different places","width":370},{"text":"inside our processes's memory","width":181},{"text":"so the last point we'll make, which is the most important, which is that it's very dangerous to return pointers to memory that is no longer valid","width":472},{"text":"for example, rather than returning nothing returning void, suppose we try to return a pointer to our array","width":659},{"text":"then though this code might compile, okay, I can get rid of \"level\" now","width":557},{"text":"it's certainly not a valid program because the pointer we get back from f1 now points to stale memory","width":631},{"text":"that memory is no longer ours to control","width":167},{"text":"it will be used in a moment for other function calls","width":182},{"text":"so always be careful if you are returning a pointer to something. make sure that that memory is still valid","width":413},{"text":"and never return a pointer to an automatic variable","width":208},{"text":"that's it for me. time for you to play. bye!","width":187}]