[{"text":"hi welcome","width":116},{"text":"so we have got a little function so far called currenttime()","width":136},{"text":"that requests 128 bytes from the heap","width":307},{"text":"and then providing we get a non-null pointer back from malloc","width":263},{"text":"we will copy in the time 2:51 PM into that memory","width":288},{"text":"and then return a pointer to the first byte of that memory so that's our little currenttime","width":262},{"text":"we've been careful to make sure that if malloc fails, perhaps our program has used all of the heap memory","width":411},{"text":"then we don't try to use that null pointer","width":207},{"text":"but now let's actually make it so that it actually makes a call to find out what the current time is","width":540},{"text":"the current time is known by the system","width":114},{"text":"so it's time to make a system call and then we will format that using a c function called ctime()","width":529},{"text":"to actually give us a human readable version of the time","width":328},{"text":"both of these functions can be found inside the include time.h","width":306},{"text":"I've commented them up here","width":113},{"text":"so the first think we can do is call time so when you call time you can pass it a pointer to a time_t variable","width":717},{"text":"or you can say actuall I'm not going to give you anything and it will still give you back the time in its result","width":512},{"text":"so let's just use the result","width":145},{"text":"so here's the number of seconds since 1970","width":534},{"text":"we'll store that inside our little variable called secondsSince1970","width":359},{"text":"but I don't want that as a value, I just want to turn that into a string","width":224},{"text":"for that there's a function called ctime, this a library function. there are other functions that give greater control to the precise formatting","width":630},{"text":"but for this demo let's just use ctime() which has some reasonable formatting that most people can understand","width":617},{"text":"this will give us back a pointer to the time","width":319},{"text":"so the time in ASCII, in otherwords in letters, in readable time","width":484},{"text":"and then we can use that and copy that result into new memory, into our result","width":526},{"text":"so one problem with ctime() is that it uses static storage","width":339},{"text":"in other words it's great if you just want to call it once, and it will use it's static storage to give you back the time in a readable format","width":674},{"text":"but don't expect that to stay around because if you call ctime() again in the future it is going to overwrite those bytes","width":455},{"text":"and that's why our little function here called currenttime() is useful","width":200},{"text":"we are going to take that temporary result and put it into some memory that is ours to control","width":403},{"text":"so it can't be overwritten","width":174},{"text":"we need to pass in seconds since midnight","width":223},{"text":"except we've got a problem here","width":208},{"text":"it doesn't actually want the value, it wants a pointer to this variable, it wants to know where in memory this variable is","width":554},{"text":"for that I have to introduce some new syntax, which is the &","width":270},{"text":"when you see & it means that I don't want to know about the variable itself, but where it is stored in memory","width":523},{"text":"tell me the address of the variable","width":305},{"text":"we didn't need this for arrays because that's what the array name gives us automatically","width":224},{"text":"but for other items we can use the & to find out where it is stored in memory","width":500},{"text":"let's compile and run it","width":374},{"text":"and we find out that my little virtual machine thinks it's Jan 1 2014","width":389},{"text":"not very accurate, we should probably change it, but it did print out what it thinks the current time","width":487},{"text":"I promised you that I'd mention a few more mistakes that we can make with heap memory","width":479},{"text":"one mistake we can make is to double free the same pointer","width":423},{"text":"this can lead to all sorts of horrendous problems because when you tell the heap that you've freed with some memory it might actually use that memory for it's own book keeping","width":719},{"text":"so it knows that the particular block of memory is free","width":275},{"text":"if you free it again it can confuse the book keeping, the pointers that the heap is using itself","width":684},{"text":"once we've freed some memory, dont free it by accident a second time!","width":208},{"text":"another common mistake in C programs is to continue using memory after we've freed it","width":536},{"text":"we shouldn't consider that memory to be valid anymore","width":175},{"text":"perhaps it's going to be reused by some other part of the program that is about to call malloc()","width":458},{"text":"and certainly we shouldn't expect anything that we've previously stored in there to be valid","width":469},{"text":"once we've freed it don't try to use the pointer again","width":188},{"text":"so for example, this would be an error","width":217},{"text":"so how can we guard against some of these errors?","width":199},{"text":"one common defensive programming technique is once we free a pointer set that pointer to be NULL","width":498},{"text":"to mean that I'm not pointing to anything anymore","width":212},{"text":"so this avoids the problem of what is called a dangling pointer error","width":429},{"text":"that now our pointer is no longer pointing to invalid memory","width":541},{"text":"that's it for me. time for you to play, bye!","width":231}]