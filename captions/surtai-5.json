[{"text":"Hi, so C is designed to be a portable language in a sense that we could write a C compiler for many many different hardware architectures","width":542},{"text":"from small embedded machines to large mainframes","width":284},{"text":"so C does not specify a precise number of bits required for, say, and integer","width":394},{"text":"instead it specifies minimums that should be supported by the architecture","width":348},{"text":"let's have a look at that. let's see how we can find out how large or small of numbers we can store in different types","width":385},{"text":"and also how many bytes each different type is ","width":209},{"text":"and even further, what is a byte?","width":183},{"text":"so let's start with our integers","width":152},{"text":"I could say hello but what's the largest value I can store inside my integer type?","width":438},{"text":"fortunately, there's some macros, some constants, defined inside limits.h","width":677},{"text":"let's find out what these are","width":209},{"text":"the int min and max is going to be %d and %d and INT_MIN and INT_MAX","width":753},{"text":"so, we'll print that out. I'll get rid of my unnecessary variable here","width":240},{"text":"let's run that","width":91},{"text":"and we see that on this particular machine, that an integer can represent numbers from roughly minus 2 billion to plus 2 billion","width":649},{"text":"a very wide range of numbers","width":135},{"text":"C promises that we'll be able to store the numbers between minus 32768 and plus 32767","width":460},{"text":"in other words, an integer will be at least 16 bits","width":292},{"text":"what else do we have? how about a character?","width":180},{"text":"well, here's a surprising thing, a character is one byte","width":225},{"text":"so what do we mean by byte?","width":113},{"text":"surely we mean 8 bits? no.","width":224},{"text":"though we often say a byte means 8 bits in modern parlance, it doesn't have to be true","width":421},{"text":"and in fact, C is very careful to say that a byte does not mean 8 bits","width":294},{"text":"it means at least 8 bits","width":101},{"text":"our character, then, is at least 8 bits","width":184},{"text":"so why this distinction?","width":122},{"text":"well, in being portable, C needs to be able to read and write every bit inside memory and each bit inside each memory should only live inside one addressable memory location","width":875},{"text":"and, it could be that architecture have very different numbers of bits it can read or write","width":515},{"text":"for example, an early PDP machine had a 36 bit wide addressable memory","width":394},{"text":"so, C does not attempt to say it's going to be exactly 8 bits","width":396},{"text":"so how do we find out how many bits are actually in a character?","width":254},{"text":"well, again, the limits.h includes a useful constants here","width":404},{"text":"a character is %d bytes","width":197},{"text":"let's go and see what that is","width":114},{"text":"so CHAR_BITS","width":129},{"text":"and we'll print that out","width":471},{"text":"on this architecture, a character is 8 bits","width":181},{"text":"that's typical on modern machines","width":283},{"text":"so what if I wanted to know the actual number of bytes in different types?","width":247},{"text":"for that, we have something called sizeof","width":306},{"text":"we can give it a type and it will tell us how many bytes (or if you prefer, how many characters) are required to hold that particular kind","width":468},{"text":"so for example, let's find out how big an integer is on this machine","width":334},{"text":"perhaps you can guess the answer already","width":136},{"text":"so, sizeof int is %d and we'll have a newline as well","width":903},{"text":"is it any surprise that the size of an integer on this particular machine happens to be 4 bytes","width":354},{"text":"and that's not surprising because we need thirty two bits to represent all numbers between minus two billion and plus two billion","width":529},{"text":"there are other integer types you'll see things like short (which is generally shorter than an int), long (which is generally longer), long long (which is even longer, still)","width":843},{"text":"and compilers even occasionally provide their own custom types as well","width":257},{"text":"notice as well that these types are signed","width":422},{"text":"so we can represent negative numbers and plus numbers","width":176},{"text":"C also provides the idea of being able to say that we can have an unsigned version","width":450},{"text":"so, for example, I can have an unsigned int","width":255},{"text":"now there is no signed bit that is included in the bitwise representation","width":439},{"text":"so that's great if you wanted to represent all the numbers between zero and 4 billion on this particular machine","width":355},{"text":"the character type can actually be signed or unsigned","width":343},{"text":"depending on the particular implementation of the C language for this particular architecture","width":404},{"text":"so that's enough for now","width":142},{"text":"in the next video, we will talk about pointers","width":137},{"text":"now it's time for you to play and learn a little bit about the basic C primitives. Bye!","width":394}]