[{"text":"hello welcome","width":111},{"text":"let's talk about getline","width":93},{"text":"so it's very very common to read in a single line of text either from the user or from a file","width":438},{"text":"and we would like it to be very easy to say hey \"let's not worry about making sure my buffer is large enough\"","width":384},{"text":"I just want to get the whole line","width":95},{"text":"and thus getline was born","width":130},{"text":"this is being adopted into the posix standard","width":215},{"text":"if you are working however with older standard and an older compiler we have to ask gcc to explicitly enable it","width":463},{"text":"so before doing our includes with stdio we need to define _GNU_SOURCE","width":575},{"text":"so if we do that we would like the gnu source additions to the standard functions","width":473},{"text":"right so if we do that now we have got a getline declaration included as part of the #include <stdio.h>","width":478},{"text":"so here is how we can use getline","width":228},{"text":"with getline we actually set up two variables","width":284},{"text":"we get getline to manipulate these directly ","width":287},{"text":"we are going to have a pointer to a buffer","width":319},{"text":"and a little int to say how big is our buffer","width":369},{"text":"well let's just check to see really if it is an int or if we should be doing a different type","width":226},{"text":"so let me pull up my favorite manpage on getline","width":362},{"text":"see that actually the correct type to use is size_t","width":398},{"text":"which is essentially an unsigned int or larger on some systems","width":259},{"text":"so let's just make a note of that","width":99},{"text":"that is the declaration that we are going to be using","width":210},{"text":"and so we will have not just a buffer to our character array","width":377},{"text":"but also size as well to say how big is our buffer","width":328},{"text":"and i will call this say capacity","width":168},{"text":"right so we could start calling this and we could say okay","width":256},{"text":"get me a line and oh i need to pass in a pointer to my buffer variable","width":441},{"text":"right and notice that the declaration here is star star asteric so it's a pointer to a pointer","width":513},{"text":"right so how did i get that","width":97},{"text":"i say okay give me the address of my variable","width":223},{"text":"and similarly for the capacity as well","width":150},{"text":"the size of the variable","width":126},{"text":"so give me the address of my capacity","width":317},{"text":"and getline is going to modify those two variables directly","width":222},{"text":"essentially if my buffer is not large enough","width":189},{"text":"it is going to free up the old buffer and then call malloc so that we get a larger buffer","width":518},{"text":"okay technically it might call realloc but let's not worry about exactly which library call it calls","width":335},{"text":"we just know that it's going to do all that buffer maintenance for us automatically","width":266},{"text":"and now we need to give it a filestream so why don't we use say stdin","width":413},{"text":"now right now our code suffers from a terrible flaw which is that we've assumed that our automatic variables buffer capacity will be set to nothing","width":546},{"text":"so the getline knows that it can't reuse what it happens to be pointing to","width":264},{"text":"so we actually need to set these to explicitly to null and the capacity to zero","width":403},{"text":"so the first time we call getline getline will see that the buffer is certainly not large enough and will allocate enough space","width":502},{"text":"we can now find out what the result is which is the number of characters getline has managed to retrieve","width":519},{"text":"or a negative value if it failed","width":127},{"text":"so let's make a note of that","width":146},{"text":"and we'll print this out","width":125},{"text":"so i'll print it out as an integer and let's have a look to see what we can find inside our buffer","width":445},{"text":"so we want the result and we want the buffer","width":227},{"text":"and lastly let's put a newline here","width":169},{"text":"okay so we'll run our little program here","width":385},{"text":"and now it's waiting for me to type something","width":368},{"text":"okay great so it says i have got six characters","width":218},{"text":"wait and i printed ABCDE","width":102},{"text":"actually the last character might be a newline character","width":355},{"text":"and quite often we don't actually need that","width":152},{"text":"so why don't we overwrite the very last character with null with a terminating byte","width":439},{"text":"so let's write the code for that","width":160},{"text":"first of all we only want to do that if we get at least one character back from getline","width":289},{"text":"so let's check that the result was positive","width":300},{"text":"and also we only want to do this if we are going to overwrite the last character which truly is a newline","width":385},{"text":"we could imagine for example reading from a file where the very last byte is not actually a newline","width":363},{"text":"so we should just check to see what we're going to write here","width":233},{"text":"so let's look inside our buffer and where do we want to look?","width":275},{"text":"well if we read one character that would be at the beginning of the buffer","width":403},{"text":"so we need to look at result minus one","width":129},{"text":"so if that is equal to the character of a newline","width":352},{"text":"then let's truncate the string","width":262},{"text":"the easiest way to do that remember is strings are just terminated by zero","width":190},{"text":"so let's just put a zero directly into that byte","width":188},{"text":"so we are going to say at the same spot set that equal to zero","width":356},{"text":"right so let's run our program again","width":534},{"text":"okay so this time it read it correctly and in our printf we didn't get that unwanted extra newline","width":570},{"text":"alright our program right now is allocating memory on the heap","width":270},{"text":"we don't do it we let getline do it","width":127},{"text":"but it's actually up to us when we finish using getline to free that buffer","width":362},{"text":"right so let's do that","width":121},{"text":"let's at the very end here we can call free on the buffer","width":316},{"text":"we don't need to do that every time we call getline because getline by default will try to for performance try to reuse the buffer for each line it gets","width":576},{"text":"so for example we could call getline twice and it would try to use the same buffer","width":511},{"text":"but the big take home message for getline is first of all","width":186},{"text":"you are going to need a pointer to a buffer and a capacity variacle which getline itself is going to change the contents of","width":470},{"text":"as you call it it can make the buffer as large as","width":304},{"text":"each time you call getline it might change that buffer to point to some new memory if the buffer needs to be larger","width":439},{"text":"secondly it's a great idea to check the return value of getline to see how many characters it managed to read","width":469},{"text":"and also to see if there was an error or not","width":138},{"text":"and the return type for that is ssize_t for a signed size integer type","width":469},{"text":"and finally it's good practice to don't forget to free the memory that is pointed at by your buffer variable","width":546},{"text":"okay that's it for me","width":87},{"text":"have fun playing bye","width":78}]